{"id": "cvdp_agentic_arithmetic_progression_generator_0001", "categories": ["cid016", "easy"], "system_message": "You are a language model that has the following file operations available at your disposal:\n  - **List files in a directory** by running one of the following commands: \n    - `ls`\n    - `tree`\n  - **Read files** by using:\n    - `cat <filename>`\n  - **Write files** by using:\n    - `echo <content> > <filename>`\n  - **Compile Verilog** by using `iverilog` such as:\n    - `iverilog -o <output_filename>.out -g2012 <verilog_code_file> <verilog_testbench_file>`\n  - **Run Simulation** by using:\n    - `vvp <output_filename>.out`\n  - **Find current working directory** by using:\n    - `pwd`\n  - **Update the contents of a text file from a old content to new content**\n    - `sed -i \"problematic_line_number s/problematic_statement/non_problematic_statement/\" Buggy_RTL_code.sv`\n  - **To access a specific line of the file**\n     - `awk 'NR==line_number' file_name.sv`\n\nYou will be given a prompt and your task is to understand it and solve the given issue by using the above-mentioned commands as needed. In the final step, you should create a Linux patch highlighting the necessary file updates to achieve the targeted goal.\n\n  You will solve the problem step by step using the following approach of \n  - thought (thinking process of the step you're going to take\n  - action (the command you will be running to get more details/context that's helpful to solve the problem)\n  - observation (the output from the action you will observe based on which you will take your next step)\n\n  The last step will be the final output summary and the patch itself in the following format \n  - thought (the summary of what you did and some introduction of the patch file itself)\n  - patch (a Linux-based patch that needs to be applied to reach the relevant solution)\n\n  The patch file should only be applied to a single file to reach the required solution.", "prompt": "### **Bug Fix Request in Arithmetic progression generator RTL**  \n\nI have the Arithmetic progression generator RTL in the current directory, and I need assistance in fixing the following bugs:  \n\n#### **Identified Bugs:**  \n1. **Overflow Handling:** Overflow occurs in `out_val` and `counter` when the input values reach their maximum limits.  \n2. **Missing Condition for Sequence Length Zero:** The design lacks a check for a sequence length of `0`, leading to incorrect behavior when `0` is applied, as operations continue instead of being skipped.\n  \nCould you help resolve these bugs in the RTL?\n", "context": {"docs/specification.md": null, "rtl/decoder_data_control_64b66b.sv": null, "rtl/encoder_control_64b66b.sv": null, "rtl/encoder_data_64b66b.sv": null, "rtl/aes128_encrypt.sv": null, "verif/tb_aes128_enc.sv": null, "rtl/aes128_decrypt.sv": null, "rtl/aes128_key_expansion.sv": null, "rtl/inv_sbox.sv": null, "rtl/sbox.sv": null, "verif/tb_aes128_dec.sv": null, "rtl/aes_encrypt.sv": null, "verif/tb_aes_encrypt.sv": null, "rtl/aes_decrypt.sv": null, "rtl/aes_ke.sv": null, "verif/tb_aes_decrypt.sv": null, "rtl/aes_dec_top.sv": null, "rtl/aes_enc_top.sv": null, "verif/tb_padding_top.sv": null, "verif/tb_des_enc.sv": null, "docs/Key_schedule.md": null, "docs/Permutations.md": null, "docs/S_box_creation.md": null, "rtl/S1.sv": null, "rtl/S2.sv": null, "rtl/S3.sv": null, "rtl/S4.sv": null, "rtl/S5.sv": null, "rtl/S6.sv": null, "rtl/S7.sv": null, "rtl/S8.sv": null, "rtl/des_enc.sv": null, "verif/tb_des_dec.sv": null, "docs/Encryption.md": null, "rtl/des_dec.sv": null, "verif/tb_3des_enc.sv": null, "verif/tb_3des_dec.sv": null, "docs/min_hamming_distance_finder_spec.md": null, "rtl/Bit_Difference_Counter.sv": null, "rtl/Bitwise_Reduction.sv": null, "rtl/Data_Reduction.sv": null, "verif/tb_Min_Hamming_Distance_Finder.sv": null, "docs/specs.md": null, "rtl/arithmetic_progression_generator.sv": "module arithmetic_progression_generator #(\n    parameter DATA_WIDTH = 16,  // Width of the input data\n    parameter SEQUENCE_LENGTH = 10 // Number of terms in the progression\n)(\n    clk,\n    resetn,\n    enable,\n    start_val,\n    step_size,\n    out_val,\n    done\n);\n  // ----------------------------------------\n  // - Local parameter definition\n  // ----------------------------------------\n  \n    localparam WIDTH_OUT_VAL = $clog2(SEQUENCE_LENGTH) + DATA_WIDTH; // Bit width of out_val to prevent overflow\n\n  // ----------------------------------------\n  // - Interface Definitions\n  // ----------------------------------------\n    input logic clk;                          // Clock signal\n    input logic resetn;                       // Active-low reset\n    input logic enable;                       // Enable signal for the generator\n    input logic [DATA_WIDTH-1:0] start_val;   // Start value of the sequence\n    input logic [DATA_WIDTH-1:0] step_size;   // Step size of the sequence\n    output logic [WIDTH_OUT_VAL-1:0] out_val; // Current value of the sequence\n    output logic done;                        // High when sequence generation is complete\n\n\n  // ----------------------------------------\n  // - Internal signals\n  // ----------------------------------------\n    logic [WIDTH_OUT_VAL-1:0] current_val;  // Register to hold the current value\n    logic [$clog2(SEQUENCE_LENGTH)-1:0] counter;  // Counter to track sequence length\n\n  // ----------------------------------------\n  // - Procedural block\n  // ----------------------------------------\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_val <= 0;\n            counter <= 0;\n            done <= 1'b0;\n        end else if (enable) begin\n            if (!done) begin\n                if (counter == 0) begin\n                    current_val <= start_val; // Initialize with start value\n                end else begin\n                    current_val <= current_val + step_size; // Compute next term\n                end\n\n                if (counter < SEQUENCE_LENGTH - 1) begin\n                    counter <= counter + 1; // Increment counter\n                end else begin\n                    done <= 1'b1; // Mark completion\n                end\n            end\n        end\n    end\n\n  // ----------------------------------------\n  // - Combinational Assignments\n  // ----------------------------------------\n    assign out_val = current_val;\n\nendmodule", "docs/algorithms.md": null, "docs/coeff_update_spec.md": null, "docs/equalizer_spec.md": null, "docs/error_calc_spec.md": null, "rtl/coeff_update.sv": null, "rtl/dynamic_equalizer.sv": null, "rtl/error_calc.sv": null, "docs/awgn_spec.md": null, "docs/equalizer_top_spec.md": null, "rtl/elevator_control_system.sv": null, "docs/tx_specification.md": null, "rtl/ethernet_fifo_cdc.sv": null, "docs/tx_mac_specification.md": null, "verif/event_scheduler_tb.sv": null, "docs/modified_specs.md": null, "rtl/event_scheduler.sv": null, "verif/tb_event_scheduler.sv": null, "rtl/column_selector.sv": null, "rtl/event_storage.sv": null, "verif/tb.sv": null, "rtl/fixed_priority_arbiter.sv": null, "verif/fixed_priority_arbiter_tb.sv": null, "docs/Modified_specification.md": null, "docs/GCD_specification.md": null, "docs/crypto_accelerator_specification.md": null, "docs/modular_exponentiation_specification.md": null, "docs/modular_multiplier_specification.md": null, "rtl/gcd_controlpath_3.sv": null, "rtl/gcd_controlpath_4.sv": null, "rtl/gcd_datapath_5.sv": null, "rtl/gcd_datapath_6.sv": null, "rtl/gcd_top_1.sv": null, "rtl/gcd_top_2.sv": null, "rtl/modular_exponentiation.sv": null, "rtl/modular_multiplier.sv": null, "rtl/lfsr_8bit.sv": null, "verif/lfsr_8bit_tb.sv": null, "rtl/bit16_lfsr.sv": null, "rtl/low_power_ctrl.sv": null, "rtl/sync_fifo.sv": null, "verif/tb_low_power_channel.sv": null, "rtl/cross_domain_sync.sv": null, "rtl/dsp_input_stage.sv": null, "rtl/dsp_output_stage.sv": null, "rtl/lfsr_generator.sv": null, "rtl/monte_carlo_dsp_monitor_top.sv": null, "verif/monte_carlo_dsp_monitor_top_tb.sv": null, "docs/multiplexer_specification.md": null, "verif/multiplexer_tb.sv": null, "docs/nbit_swizzling_spec.md": null, "verif/nbit_swizzling_tb.sv": null, "docs/nmea_decoder_spec.md": null, "rtl/nmea_decoder.sv": null, "verif/nmea_decoder_tb.sv": null, "docs/fifo.md": null, "rtl/fifo_memory.sv": null, "rtl/read_to_write_pointer_sync.sv": null, "rtl/rptr_empty.sv": null, "rtl/wptr_full.sv": null, "rtl/write_to_read_pointer_sync.sv": null, "docs/spec.md": null, "verif/async_filo_tb.sv": null, "docs/axilite_to_pcie_config_module.md": null, "rtl/axi4lite_to_pcie_cfg_bridge.sv": null, "rtl/axis_broadcast.sv": null, "verif/tb_axis_broadcast.sv": null, "docs/axis_to_uart_tx_specs.md": null, "docs/uart_rx_to_axis_specs.md": null, "rtl/barrel_shifter.sv": null, "verif/barrel_shifter_tb.sv": null, "rtl/bcd_adder.sv": null, "rtl/full_adder.sv": null, "rtl/four_bit_adder.sv": null, "rtl/search_binary_search_tree.sv": null, "rtl/delete_node_binary_search_tree.sv": null, "docs/bst_operations.md": null, "rtl/binary_search_tree_sort_construct.sv": null, "docs/Spec.md": null, "verif/tb_binary_to_gray.sv": null, "verif/tb_custom_byte_enable_ram.sv": null, "verif/cache_controller_tb.sv": null, "rtl/caesar_cipher.sv": null, "verif/caesar_cipher_tb.sv": null, "verif/tb_pseudoRandGenerator_ca.sv": null, "docs/continuous_adder_specification.md": null, "verif/continuous_adder_tb.sv": null, "rtl/fifo_buffer.sv": null, "verif/tb_fifo_buffer.sv": null, "docs/direct_map_cache_spec.md": null, "verif/tb_direct_map_cache.sv": null, "rtl/direct_map_cache.sv": null, "rtl/dual_port_memory.sv": null, "rtl/gen_cos_sin_lut.sv": null, "rtl/phase_lut.sv": null, "rtl/phase_rotation.sv": null, "rtl/power4.sv": null, "rtl/saturation.sv": null, "rtl/top_phase_rotation.sv": null, "docs/spec_viterbi.md": null, "docs/spec_slicer_top.md": null, "docs/spec_top_phase_rotation.md": null, "rtl/slicer.sv": null, "rtl/slicer_top.sv": null, "docs/swizzler_specification.md": null, "verif/swizzler_tb.sv": null, "rtl/swizzler.sv": null, "docs/sync_serial_communication_tx_rx_spec.md": null, "verif/sync_serial_communication_tb.sv": null, "rtl/weight_stationary_pe.sv": null, "verif/systolic_array_tb.sv": null, "rtl/thermostat.v": null, "docs/Traffic_controller.md": null, "rtl/traffic_light_controller.sv": null, "docs/Universal_Shift_Register_spec.md": null, "verif/tb_universal_shift_register.sv": null, "rtl/universal_shift_register.sv": null, "docs/spec_conj.md": null, "docs/spec_cross_correlation.md": null, "docs/spec_detect_sequence.md": null, "rtl/adder_2d_layers.sv": null, "rtl/adder_tree_2d.sv": null, "rtl/correlate.sv": null, "rtl/cross_correlation.sv": null, "docs/valid_modes.md": null, "docs/words_counting.md": null, "rtl/detect_sequence.sv": null, "docs/proc_fsm_spec.md": null, "docs/adder_tree.md": null, "docs/coeff_ram.md": null, "docs/poly_decimator.md": null, "docs/poly_filter.md": null, "docs/shift_register.md": null, "rtl/adder_tree.sv": null, "rtl/coeff_ram.sv": null, "rtl/poly_filter.sv": null, "rtl/shift_register.sv": null, "docs/prbs_specification.md": null, "rtl/prbs_gen_check.sv": null, "rtl/fsm.sv": null, "verif/fsm_tb.sv": null, "rtl/CA_1.sv": null, "rtl/CA_2.sv": null, "rtl/CA_3.sv": null, "rtl/CA_4.sv": null, "rtl/rgb_color_space_conversion.sv": null, "rtl/APBGlobalHistoryRegister.v": null, "docs/signed_comparator_specification.md": null, "verif/signed_comparator_tb.sv": null, "rtl/sorting_engine.sv": null, "rtl/brick_sort.sv": null, "rtl/bubble_sort.sv": null, "rtl/merge_sort.sv": null, "rtl/selection_sort.sv": null}, "patch": {"rtl/top_64b66b_codec.sv": null, "rtl/aes128_encrypt.sv": null, "rtl/aes128_decrypt.sv": null, "rtl/aes128_key_expansion.sv": null, "rtl/aes_encrypt.sv": null, "rtl/aes_decrypt.sv": null, "rtl/aes_ke.sv": null, "rtl/aes_dec_top.sv": null, "rtl/aes_enc_top.sv": null, "rtl/padding_top.sv": null, "rtl/S1.sv": null, "rtl/S2.sv": null, "rtl/S3.sv": null, "rtl/S4.sv": null, "rtl/S5.sv": null, "rtl/S6.sv": null, "rtl/S7.sv": null, "rtl/S8.sv": null, "rtl/des_enc.sv": null, "rtl/des_dec.sv": null, "rtl/des3_enc.sv": null, "rtl/des3_dec.sv": null, "rtl/Min_Hamming_Distance_Finder.sv": null, "rtl/pcie_endpoint.sv": null, "rtl/arithmetic_progression_generator.sv": "", "rtl/coeff_update.sv": null, "rtl/dynamic_equalizer.sv": null, "rtl/error_calc.sv": null, "rtl/awgn.sv": null, "rtl/equalizer_top.sv": null, "rtl/elevator_control_system.sv": null, "rtl/ethernet_mii_tx.sv": null, "rtl/ethernet_dp_ram.sv": null, "rtl/ethernet_mac_tx.sv": null, "rtl/event_scheduler.sv": null, "rtl/event_array.sv": null, "rtl/event_storage.sv": null, "rtl/fixed_priority_arbiter.sv": null, "rtl/crypto_accelerator.sv": null, "rtl/modular_exponentiation.sv": null, "rtl/hdbn_decoder.sv": null, "rtl/hdbn_encoder.sv": null, "rtl/hdbn_top.sv": null, "rtl/jpeg_runlength_enc.sv": null, "rtl/jpeg_runlength_rzs.sv": null, "rtl/jpeg_runlength_stage1.sv": null, "rtl/lfsr_8bit.sv": null, "rtl/bit16_lfsr.sv": null, "rtl/low_power_channel.sv": null, "rtl/cross_domain_sync.sv": null, "rtl/dsp_input_stage.sv": null, "rtl/dsp_output_stage.sv": null, "rtl/lfsr_generator.sv": null, "rtl/monte_carlo_dsp_monitor_top.sv": null, "rtl/multiplexer.sv": null, "rtl/nbit_swizzling.sv": null, "rtl/nmea_decoder.sv": null, "rtl/async_fifo.sv": null, "rtl/async_filo.sv": null, "rtl/axi4lite_to_pcie_cfg_bridge.sv": null, "rtl/axis_broadcast.sv": null, "rtl/axis_to_uart_tx.sv": null, "rtl/uart_rx_to_axis.sv": null, "rtl/barrel_shifter.sv": null, "rtl/bcd_adder.sv": null, "rtl/bcd_top.sv": null, "rtl/multi_digit_bcd_add_sub.sv": null, "verif/tb_bcd_adder.sv": null, "rtl/search_binary_search_tree.sv": null, "rtl/binary_search_tree_sort.sv": null, "rtl/bst_operations.sv": null, "rtl/bst_tree_construct.sv": null, "rtl/binary_to_gray.sv": null, "rtl/custom_byte_enable_ram.sv": null, "rtl/cache_controller.sv": null, "rtl/caesar_cipher.sv": null, "rtl/pseudoRandGenerator_ca.sv": null, "rtl/cic_decimator.sv": null, "rtl/cipher.sv": null, "rtl/continuous_adder.sv": null, "rtl/csr_apb_interface.sv": null, "verif/csr_apb_interface_tb.sv": null, "rtl/fifo_buffer.sv": null, "rtl/dig_stopwatch.sv": null, "rtl/dig_stopwatch_top.sv": null, "verif/dig_stopwatch_tb.sv": null, "rtl/direct_map_cache.sv": null, "rtl/dma_xfer_engine.sv": null, "rtl/door_lock.sv": null, "rtl/dual_port_memory.sv": null, "rtl/phase_rotation_viterbi.sv": null, "rtl/slicer.sv": null, "rtl/slicer_top.sv": null, "rtl/phase_rotation.sv": null, "rtl/top_phase_rotation.sv": null, "rtl/spi_complex_mult.sv": null, "rtl/swizzler.sv": null, "rtl/swizzler_supervisor.sv": null, "rtl/sync_serial_communication_top.sv": null, "rtl/systolic_array.sv": null, "rtl/security_module.v": null, "rtl/thermostat_secure_top.v": null, "rtl/timer_module.sv": null, "rtl/traffic_light_controller_top.sv": null, "rtl/ttc_counter_lite.sv": null, "verif/ttc_counter_lite_tb.sv": null, "rtl/universal_shift_register.sv": null, "rtl/phase_lut.sv": null, "rtl/detect_sequence.sv": null, "rtl/adder_2d_layers.sv": null, "rtl/correlate.sv": null, "rtl/cross_correlation.sv": null, "rtl/control_fsm.sv": null, "rtl/poly_decimator.sv": null, "rtl/scrambler_descrambler.sv": null, "rtl/fsm.sv": null, "rtl/queue.sv": null, "rtl/rc5_enc_16bit.sv": null, "rtl/rgb_color_space_hsv.sv": null, "rtl/rgb_color_space_conversion.sv": null, "rtl/APBGlobalHistoryRegister.v": null, "rtl/APBGlobalHistoryRegister_secure_top.v": null, "rtl/sigma_delta_audio.sv": null, "rtl/signed_comparator.sv": null, "rtl/sorting_engine.sv": null, "rtl/order_matching_engine.sv": null}, "harness": {"docker-compose.yml": "services:\n\n  01-new-tb:\n    image: __OSS_SIM_IMAGE__\n    volumes:\n      - ./src/:/src/:ro\n    working_dir : /code/rundir\n    env_file    : ./src/.env\n    command     : pytest -s -o cache_dir=/rundir/harness/.cache /src/test_runner.py -v\n\n", "src/.env": "SIM             = icarus\nWAVE            = False\nTOPLEVEL_LANG   = verilog\nVERILOG_SOURCES = /code/rtl/arithmetic_progression_generator.sv\nTOPLEVEL        = arithmetic_progression_generator\nMODULE          = test_arithmetic_progression_generator\nPYTHONPATH      = /src\nHASH            = 89e25e0bcc604d170ede28f3649c3623cb94c207", "src/test_runner.py": "import os\nfrom cocotb_tools.runner import get_runner\nimport pytest\nimport random\n\n# Fetch environment variables for simulation setup\nverilog_sources = os.getenv(\"VERILOG_SOURCES\").split()\ntoplevel_lang   = os.getenv(\"TOPLEVEL_LANG\")\nsim             = os.getenv(\"SIM\", \"icarus\")\ntoplevel        = os.getenv(\"TOPLEVEL\")\nmodule          = os.getenv(\"MODULE\")\nwave            = bool(os.getenv(\"WAVE\"))\n\n# Runner function\ndef runner(DATA_WIDTH: int=0, SEQUENCE_LENGTH: int=0, start_val: int=0, step_size: int=0, enable: int=0):\n    # Plusargs to pass simulation parameters enable\n    plusargs = [\n        f'+start_val={start_val}', \n        f'+step_size={step_size}',\n        f'+enable={enable}'\n    ]\n    \n    parameters = {\n        \"DATA_WIDTH\": DATA_WIDTH,\n        \"SEQUENCE_LENGTH\": SEQUENCE_LENGTH\n    }\n\n    # Debug information\n    print(f\"[DEBUG] Running simulation with DATA_WIDTH={DATA_WIDTH}, SEQUENCE_LENGTH={SEQUENCE_LENGTH}\")\n    print(f\"[DEBUG] Start Value: {start_val}, Step Size: {step_size}\")\n    print(f\"[DEBUG] Parameters: {parameters}\")\n    \n    # Configure the simulation runner\n    runner = get_runner(sim)\n    runner.build(\n        sources=verilog_sources,\n        hdl_toplevel=toplevel,\n        parameters=parameters,\n        always=True,\n        clean=True,\n        waves=True,\n        verbose=True,\n        timescale=(\"1ns\", \"1ns\"),\n        log_file=\"sim.log\"\n    )\n    \n    runner.test(hdl_toplevel=toplevel, test_module=module, waves=wave, plusargs=plusargs)\n\n# Pytest parameterization\n@pytest.mark.parametrize(\"DATA_WIDTH\", [random.randint(4, 32)])\n@pytest.mark.parametrize(\"SEQUENCE_LENGTH\", [0])\n@pytest.mark.parametrize(\"test\", range(5))  # Run 50 tests\ndef test_arithmetic_progression_generator(DATA_WIDTH, SEQUENCE_LENGTH,test):\n    runner(DATA_WIDTH=DATA_WIDTH, SEQUENCE_LENGTH=SEQUENCE_LENGTH)\n", "src/test_top_64b66b_codec.py": null, "src/harness_library.py": "\nfrom cocotb.triggers import FallingEdge, RisingEdge, Timer\nimport random\n\nasync def reset_dut(reset, duration_ns = 10):\n    # Restart Interface\n    reset.value = 1\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 0\n    await Timer(duration_ns, units=\"ns\")\n    reset.value = 1\n    await Timer(duration_ns, units='ns')\n    reset._log.debug(\"Reset complete\")\n\n\nasync def dut_init(dut):\n    # iterate all the input signals and initialize with 0\n    for signal in dut:\n        if signal._type == \"GPI_NET\":\n            signal.value = 0\n\n", "src/test_aes128_encrypt.py": null, "src/test_aes128_decrypt.py": null, "src/test_aes_encrypt.py": null, "src/test_aes_decrypt.py": null, "src/.env_decrypt": null, "src/.env_encrypt": null, "src/test_aes_dec_top.py": null, "src/test_aes_enc_top.py": null, "src/test_padding_top.py": null, "src/test_runner_dec_top.py": null, "src/test_runner_enc_top.py": null, "src/test_des_enc.py": null, "src/test_des_dec.py": null, "src/test_des3_enc.py": null, "src/.env_des_dec": null, "src/.env_des_enc": null, "src/test_des3_dec.py": null, "Dockerfile": null, "src/test_Min_Hamming_Distance_Finder.py": null, "src/test_pcie_ep.py": null, "src/test_arithmetic_progression_generator.py": "# File: arithmetic_progression_generator.py\n\nimport cocotb\nfrom cocotb.clock import Clock\nfrom cocotb.triggers import FallingEdge, RisingEdge, ClockCycles, Timer\nimport harness_library as hrs_lb\nimport random\nimport time\nimport math\n\ndef clog2(N):\n    return math.ceil(math.log2(N))\n\n@cocotb.test()\nasync def test_arithmetic_progression_generator(dut):\n     \n    # Randomly execute this statement in one of the iterations\n    MIN_CLOCK_PERIOD = 4\n    # clock_period_ns = random.randint(MIN_CLOCK_PERIOD, 15)  # For example, 10ns clock period\n    clock_period_ns = 10  # For example, 10ns clock period\n    cocotb.start_soon(Clock(dut.clk, clock_period_ns, units='ns').start())\n    print(\"[INFO] Clock started.\")\n    \n    # Initialize DUT\n    await hrs_lb.dut_init(dut)\n    \n    # Apply reset \n    await hrs_lb.reset_dut(dut.resetn, clock_period_ns)\n    await RisingEdge(dut.clk)   \n    await RisingEdge(dut.clk)   \n\n    # Extract parameters from the DUT\n    DATA_WIDTH = int(dut.DATA_WIDTH.value)\n    SEQUENCE_LENGTH = int(dut.SEQUENCE_LENGTH.value)\n    if SEQUENCE_LENGTH == 0:\n        SEQUENCE_LENGTH_MOD = 1\n        EXPECTED_WIDTH_OUT_VAL = 1 + (DATA_WIDTH)\n    else :\n        SEQUENCE_LENGTH_MOD = SEQUENCE_LENGTH\n        EXPECTED_WIDTH_OUT_VAL = clog2(SEQUENCE_LENGTH_MOD) + (DATA_WIDTH)\n    WIDTH_OUT_VAL = int(dut.WIDTH_OUT_VAL.value)\n    \n    print(f\"DATA_WIDTH= {DATA_WIDTH}, SEQUENCE_LENGTH= {SEQUENCE_LENGTH_MOD}, WIDTH_OUT_VAL={WIDTH_OUT_VAL} \")\n    \n    reset_system = 0\n    # if random.choice([True, False]):\n    #    reset_system = 1\n    #    N_cycles_reset = random.randint(2, 5)\n    #    Positive_delta = random.randint(3, 10)\n    #    # Generate start_cycle mostly greater than SEQUENCE_LENGTH\n    #    if random.random() < 0.8:  # 80% chance to be greater\n    #        start_cycle_reset = random.randint(SEQUENCE_LENGTH_MOD + 2 , SEQUENCE_LENGTH_MOD + Positive_delta)\n    #    else:  # 20% chance to be less\n    #        start_cycle_reset = random.randint(1, SEQUENCE_LENGTH_MOD - 1)\n    #    print(f\"Reset will be given at {start_cycle_reset + 1} cycle for {N_cycles_reset} cycles!\")\n       \n    Dessert_enable = 0\n    # if random.choice([True, False]):\n    #    Dessert_enable = 1\n    #    N_cycles = random.randint(1, 3)\n    #    start_cycle = random.randint(1, SEQUENCE_LENGTH_MOD-1)\n    #    print(f\"Enable will be deasserted at {start_cycle + 1} cycle for {N_cycles} cycles !\")\n\n    # Test-specific variables\n    MAX_VALUE =  (1 << DATA_WIDTH) - 1 \n    start_val = random.randint(1, MAX_VALUE)  # Example start value\n    step_size = random.randint(1, MAX_VALUE)  # Example step size\n    if random.choice([True, False]):\n        start_val = MAX_VALUE  # Example start value\n        step_size = MAX_VALUE  # Example start value\n        print(f\"Overflow check !\")\n        print(f\"WIDTH_OUT_VAL = {WIDTH_OUT_VAL}, EXPECTED_WIDTH_OUT_VAL = {EXPECTED_WIDTH_OUT_VAL}\")\n\n    cycle_num = random.randint( SEQUENCE_LENGTH_MOD + 2, 100)\n    cycle = 0\n    expected_value = 0\n    expected_value_s1 = 0\n    expected_done = 0\n    expected_done_s1 = 0\n    counter = 0\n    reset = 0\n    \n    for cycle in range(cycle_num):  # Run the test for random number of cycles\n        ###############################################################\n        ######### Applying reset to the system randomly\n        ###############################################################\n        dut.resetn.value = 1\n        if reset_system == 1 :\n            #reset applied for N cycles after start_cycle \n            reset = 0\n            if cycle >= start_cycle_reset and cycle < start_cycle_reset + N_cycles_reset  :\n                reset = 1\n                dut.resetn.value = 0\n                print(f\"Reset applied for {N_cycles_reset} cycles!\")\n                expected_value = 0\n                expected_value_s1 = 0\n                expected_value_s2 = 0\n                expected_done = 0\n                expected_done_s1 = 0\n                expected_done_s2 = 0\n                counter = 0\n        ###############################################################\n        ######### Controlling enable signal randomly\n        ###############################################################               \n        enable = 1\n        if Dessert_enable == 1 :\n            #valid in 0 for N cycles after start_cycle \n            if cycle >= start_cycle and cycle < start_cycle + N_cycles  :\n               enable = 0\n               print(f\"Enable deasserted for {N_cycles} cycles!\")\n        dut.enable.value = enable\n        dut.start_val.value = start_val\n        dut.step_size.value = step_size\n        \n        ###############################################################\n        ######### Verification function\n        ###############################################################\n        if enable == 1 and not reset and SEQUENCE_LENGTH > 0:\n            if counter < SEQUENCE_LENGTH :\n                if counter == 0 : \n                    expected_value = start_val\n                    expected_done = 0\n                    counter = counter + 1\n                else :\n                    expected_value += step_size\n                    expected_done = 0\n                    counter = counter + 1\n            else :\n                expected_done = 1\n        else : \n            expected_value = expected_value\n            expected_done = expected_done\n            counter = counter\n        \n        ###############################################################\n        ######### Clock rise edge\n        ###############################################################\n        expected_value_s2 = expected_value_s1\n        expected_done_s2 = expected_done_s1\n        await RisingEdge(dut.clk)   \n        expected_value_s1 = expected_value\n        expected_done_s1 = expected_done\n        \n        ###############################################################\n        ######### Actual RTL module\n        ############################################################### \n        actual_value =dut.out_val.value.to_unsigned()\n        actual_done = dut.done.value.to_unsigned()\n\n        ###############################################################\n        ######### Assertions\n        ############################################################### \n        ##Assertion to check data out, assertion to check overflow\n        assert actual_value == expected_value_s2, f\"Error at step {i}: expected {expected_value_s2}, got {int(dut.out_val.value)}\"\n        ##Assertion to check done \n        assert actual_done == expected_done, \"Done signal not asserted after sequence completion\"\n        ##Assertion to check val_out width \n        assert WIDTH_OUT_VAL == EXPECTED_WIDTH_OUT_VAL, \"Wrong calculation of WIDTH_OUT_VAL\"\n        ##Assertion to check reset \n        if reset == 1 :\n            assert actual_value == expected_value_s2 == 0 , f\"Error at step {i}:At reset, expected {expected_value_s2}, got {actual_value}\"\n            assert actual_done == expected_done == 0 , f\"Error at step {i}:At reset, expected_done {expected_done}, got {actual_done}\"\n\n        print(f\"[DEBUG] Cycle {cycle+1}/{cycle_num}: start_val = {hex(start_val)}\")\n        print(f\"[DEBUG] Cycle {cycle+1}/{cycle_num}: step_size = {step_size}\")\n        print(f\"[DEBUG] Cycle {cycle+1}/{cycle_num}: enable = {enable}\")\n        print(f\"[DEBUG] Cycle {cycle+1}/{cycle_num}: expected_value = {hex(expected_value_s2)}, expected_done = {expected_done}\")\n        print(f\"[DEBUG] Cycle {cycle+1}/{cycle_num}: actual_value   = {hex(actual_value)}, actual_done   = {actual_done}\")\n        print(f\"\\n\")\n        ", "src/test_dynamic_equalizer_harness.py": null, "src/test_equalizer_top_harness.py": null, "src/elevator_control.py": null, "src/test_ethernet_mii.py": null, "src/test_ethernet_mac_tx.py": null, "src/test_event_scheduler.py": null, "src/.env_event_storage": null, "src/test_event_array.py": null, "src/test_event_storage.py": null, "src/test_runner_event_array.py": null, "src/test_runner_event_storage.py": null, "src/test_fixed_priority_arbiter.py": null, "src/test_crypto_accelerator.py": null, "src/test_hdbn_top.py": null, "src/test_jpeg_runlength_enc.py": null, "src/test_lfsr_8bit.py": null, "src/test_bit16_lfsr.py": null, "src/test_low_power_channel.py": null, "src/test_monte_carlo_dsp_monitor_top.py": null, "src/test_multiplexer.py": null, "src/test_nbit_swizzling.py": null, "src/test_nmea_decoder.py": null, "src/test_async_fifo.py": null, "src/test_async_filo.py": null, "src/test_axil_pcie_cfg.py": null, "src/test_axis_broadcast.py": null, "src/test_axis_to_uart_tx.py": null, "src/uart_rx_to_axis_test.py": null, "src/test_barrel_shifter.py": null, "src/test_bcd_adder.py": null, "src/test_delete_node_binary_search_tree.py": null, "src/test_bst_operations.py": null, "src/test_binary_to_gray.py": null, "src/test_custom_byte_enable_ram.py": null, "src/test_cache_controller.py": null, "src/test_caesar_cipher.py": null, "src/test_pseudoRandGenerator_ca.py": null, "src/test_cic_decimator.py": null, "src/test_cipher.py": null, "src/test_continuous_adder.py": null, "src/test_csr_apb_interface.py": null, "src/test_fifo_buffer.py": null, "src/test_dig_stopwatch.py": null, "src/test_direct_map_cache.py": null, "src/test_dma_xfer_engine.py": null, "src/test_door_lock.py": null, "src/test_dual_port_memory.py": null, "src/test_phase_rotation_viterbi.py": null, "src/test_slicer_top.py": null, "src/test_phase_rot.py": null, "src/test_spi_complex_mult_harness.py": null, "src/test_swizzler.py": null, "src/test_swizzler_supervisor.py": null, "src/test_sync_serial_communication.py": null, "src/test_systolic_array.py": null, "src/test_thermostat_secure_top.py": null, "src/test_traffic_light_controller_top.py": null, "src/test_ttc_counter_lite.py": null, "src/test_universal_shift_register.py": null, "src/test_phase_lut.py": null, "src/test_detect_sequence.py": null, "src/test_control_fsm.py": null, "src/test_poly_decimator/.env": null, "src/test_poly_decimator/harness_library.py": null, "src/test_poly_decimator/test_poly_decimator.py": null, "src/test_poly_decimator/test_runner.py": null, "src/test_scrambler_descrambler.py": null, "src/test_fsm.py": null, "src/test_queue.py": null, "src/test_rc5_enc_16bit.py": null, "src/test_rgb_color_space_hsv.py": null, "src/test_rgb_color_space_conversion.py": null, "src/test_APBGlobalHistoryRegister_secure_top.py": null, "src/test_sigma_delta_audio.py": null, "src/test_signed_comparator.py": null, "src/test_sorting_engine.py": null, "src/test_order_matching_engine.py": null}}
